#' Generate new spanning trees for each cluster
#'
#' \code{graphHyper} resamples the spanning trees which together partition the \code{full_graph} (as generated by
#' \code{\link{constructGraph}}) into the clusters specified by \code{membership}. It does this by first resampling every
#' edge weight from the full graph, with edges connecting vertices currently assigned to different clusters being drawn from
#' a uniform (0.5, 1) distribution (weighted more heavily), and edges connecting vertices currently assigned to the same
#' cluster being drawn from a uniform (0, 0.5) distribution (weighted less heavily). Then, the minimum spanning tree across the
#' entire graph is recalculated using these new weights. By removing the inter-cluster edges from this new MST (see
#' \code{\link{clusterGraph}}), the resultant graph has the same vertex membership, but the individual trees which make up
#' the spanning forest likely have a different set of edges.
#'
#' @param full_graph An object of class 'graph' from the \code{\link[igraph]{igraph}} package
#' @param membership  A vector of integers of length N with k unique integers (1 < k <= N) which map each vertex to a cluster
#'
#' @return A list containing two elements:
#' \item{graph}{The input graph with each cluster having a new minimum spanning tree based on resampled edge weights}
#' \item{membership}{A vector of integers of length N with k unique integers which map each vertex to a cluster}
#' @export
#'
#' @seealso
#' \code{\link{constructClusters}}, \code{\link{graphDeath}}, \code{\link{graphChange}}, \code{\link{graphBirth}}
#'
#' @references
#' Luo, Z.T. (*), Sang, H. and Mallick, B.K. (2021), BAST: Bayesian Additive Regression Spanning Trees
#' for Complex Constrained Domain
#'
#' Luo, Z.T. (*), Sang, H. and Mallick, B.K. (2021), A Bayesian Contiguous Partitioning Method for
#' Learning Clustered Latent Variables, Journal of Machine Learning Research, 22, 1-52.
#'
#' @examples
#' set.seed(1)
#' coords = data.frame(lon = rnorm(100), lat = rnorm(100))
#' g = constructGraph(coords, 5)
#' clust_out = constructClusters(g, 8, minclust = 6)
#' plot(clust_out$spanning_forest,
#'      layout = as.matrix(coords),
#'      vertex.color = clust_out$membership,
#'      edge.arrow.mode = 0)
#' g_resample = graphHyper(g, clust_out$membership)
#' plot(g_resample$graph,
#'      layout = as.matrix(coords),
#'      vertex.color = g_resample$membership,
#'      edge.arrow.mode = 0)
graphHyper = function(full_graph, membership) {
  # Test that membership is valid
  N = igraph::vcount(full_graph)
  if(length(membership) != N) {
    stop("membership is of incorrect length, should be same length as vcount of graph")
  }
  # Test that full_graph is connected
  if(!igraph::is.connected(full_graph)) {
    warning("full_graph is not connected; clusters could be incorrect\n")
  }
  # Get the vector of edge betweenness of the full graph
  betweenness = edgeBetweenClust(full_graph, membership)
  # Get the vector of edges which are in between clusters
  between_edges = igraph::E(full_graph)[betweenness]
  # Get the vector of edges which are within clusters
  within_edges = igraph::E(full_graph)[!betweenness]
  #Initialize vector of weights
  weight = rep(0, igraph::ecount(full_graph))
  # Sample between cluster edge weights and assign them (uniform from 0.5 to 1)
  weight[betweenness] = stats::runif(length(between_edges), 0.5, 1)
  # Sample within cluster edge weights and assign them (uniform from 0 to 0.5)
  weight[!betweenness] = stats::runif(length(within_edges), 0, 0.5)
  # Recalculate the MST
  minspantree = igraph::mst(full_graph, weights = weight)
  # Remove inter-cluster edges to recover original partition
  resampled_graph = clusterGraph(minspantree, membership)
  # Return updated graph and same membership
  return(list(graph = resampled_graph, membership = membership))
}
