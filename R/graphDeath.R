#' Perform a cluster death operation (merge an existing cluster)
#'
#' \code{graphDeath} takes in a spanning forest graph with k disconnected components corresponding to
#' the vector of cluster assignments 'membership' and merges two connected clusters together. It requires the original
#' graph (as generated by \code{\link{constructGraph}}) to determine what edges in the modified graph are available to
#' be returned in order to connect disconnected components. From the list of edges which connect vertices belonging
#' to different clusters (see \code{\link{edgeBetweenClust}}), one is uniformly randomly selected and returned to
#' the output graph, reducing the number of clusters by one.
#'
#' @param graph An object of class 'graph' from the \code{\link[igraph]{igraph}} package
#' @param membership A vector of integers of length N with k unique integers (1 < k <= N) which map each vertex to a cluster
#' @param full_graph An object of class 'graph' from the \code{\link[igraph]{igraph}} package; 'graph' should be a subgraph of full_graph
#'
#' @return A list containing two elements:
#' \item{graph}{The input graph with 1 additional active edge}
#' \item{membership}{A vector of integers of length N with k - 1 unique integers which map each vertex to a cluster}
#' \item{new_clust_ids}{Vertex keys of the vertices belonging to the newly unified cluster}
#' \item{old_clust_ids}{Vertex keys of the vertices belonging only to the cluster being merged which has a higher number}
#' @export
#'
#' @seealso
#' \code{\link{constructClusters}}, \code{\link{graphBirth}}, \code{\link{graphChange}}, \code{\link{graphHyper}}
#'
#' @references
#' Luo, Z.T. (*), Sang, H. and Mallick, B.K. (2021), BAST: Bayesian Additive Regression Spanning Trees
#' for Complex Constrained Domain
#'
#' Luo, Z.T. (*), Sang, H. and Mallick, B.K. (2021), A Bayesian Contiguous Partitioning Method for
#' Learning Clustered Latent Variables, Journal of Machine Learning Research, 22, 1-52.
#'
#' @examples
#' set.seed(1)
#' coords = data.frame(lon = rnorm(50), lat = rnorm(50))
#' g = constructGraph(coords, 6)
#' clust_out = constructClusters(g, 8, minclust = 3)
#' plot(clust_out$spanning_forest,
#'      layout = as.matrix(coords),
#'      vertex.color = clust_out$membership,
#'      edge.arrow.mode = 0)
#' g_7_clusters = graphDeath(clust_out$spanning_forest,
#'                           clust_out$membership,
#'                           g)
#' plot(g_7_clusters$graph,
#'      layout = as.matrix(coords),
#'      vertex.color = g_7_clusters$membership,
#'      edge.arrow.mode = 0)
graphDeath = function(graph, membership, full_graph) {
  # Test that membership is valid
  N = igraph::vcount(graph)
  if(length(membership) != N) {
    stop("membership is of incorrect length, should be same length as vcount of graph")
  }
  # Test that graph has the same number of vertices as full_graph
  if(N != igraph::vcount(full_graph)) {
    stop("graph does not have the same number of vertices as full_graph")
  }
  k = length(unique(membership))
  # Test that k is valid
  if(k <= 1) {
    stop("Not enough clusters; need at least 2 clusters to be able to merge")
  }
  # Get a vector of which of the edges which are between the existing clusters
  betweenness = edgeBetweenClust(full_graph, membership)
  # Use betweenness to make a vector of the edges which are between clusters
  between_edges = igraph::E(full_graph)[betweenness]
  # Select one to return to the graph
  returning_edge = sample(between_edges, 1)
  # Get vertex IDs which the returning edge connects
  connecting_vertices = igraph::ends(full_graph, returning_edge)
  # Get vertices belonging to the higher cluster number (the 'old' cluster)
  old_clust_ids = which(membership == max(membership[connecting_vertices]))
  # Get vertices belonging to the newly merged cluster
  new_clust_ids = which(membership %in% membership[connecting_vertices])
  # Add the edge back to graph
  merged_graph = igraph::add_edges(graph, connecting_vertices)
  # Update the membership of each cluster
  merged_membership = igraph::components(merged_graph)$membership
  # Return the updated graph and new membership
  return(list(graph = merged_graph, membership = merged_membership, new_clust_ids = new_clust_ids, old_clust_ids = old_clust_ids))
}
