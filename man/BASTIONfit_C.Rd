% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppWrappers.R
\name{BASTIONfit_C}
\alias{BASTIONfit_C}
\title{BASTION Regression using Rcpp}
\usage{
BASTIONfit_C(Y, graph, init_vals, hyperpars, MCMC, BURNIN, THIN, seed = NULL)
}
\arguments{
\item{Y}{A numeric vector of responses with length equal to the number of vertices in 'graph'}

\item{graph}{An object of class 'graph' from the \code{\link[igraph]{igraph}} package. The graph must have weights for each edge}

\item{init_vals}{A named list with the following components:
\item{sigmasq_y}{A numeric value}
\item{mu}{A list of length M where each element is a vector of length 1}}

\item{hyperpars}{A named list with the following components:
\item{k_max}{An integer, the maximum number of clusters for each weak learner}
\item{M}{An integer, the number of weak learners}
\item{lambda_k}{A numeric value}
\item{lambda_s}{A numeric value}
\item{nu}{A numeric value}
\item{sigmasq_mu}{A numeric value}}

\item{MCMC}{An integer, the number of iterations for the MCMC}

\item{BURNIN}{An integer, the number of initial iterations for the MCMC before recording output}

\item{THIN}{An integer, specifies the thinning interval}

\item{seed}{Optional, value to feed to R's set.seed function}
}
\value{
A named list with the following components:
\item{mu_out}{List of fitted values for mu for each weak learner at each output interval}
\item{sigmasq_y_out}{List of sigmasq_y at each output interval}
\item{cluster_out}{List of cluster membership of each vertex for each weak learner at each output interval}
\item{log_post_out}{List of the log of the posterior probability at each output interval}
}
\description{
BASTION Regression using Rcpp
}
\examples{
test_coords = data.frame(x = c(0,1,1,0), y = c(1,0,1,0)) # observed locations
test_graph = constructGraph(test_coords, 3)
# Not run: plot this graph using ggraph package
# ggraph(test_graph, layout = test_coords) + geom_node_point() + geom_edge_link0()
n = igraph::vcount(test_graph)
z = c(1,2,3,4) # response

M = 3      # number of weak learners
k_max = 2   # maximum number of clusters per weak learner
mu = list() # initial values of mu
cluster = matrix(1, nrow = n, ncol = M)  # initial cluster memberships
for(m in 1:M) {
  mu[[m]] = c(0)
}

init_val = list()
init_val[['mu']] = mu
init_val[['sigmasq_y']] = 1


# find lambda_s
nu = 3; q = 0.9
quant = qchisq(1-q, nu)
lambda_s = quant * var(z) / nu

hyperpar = c()
hyperpar['sigmasq_mu'] = (0.5/(2*sqrt(M)))^2
hyperpar['lambda_s'] = lambda_s
hyperpar['nu'] = nu
hyperpar['lambda_k'] = 4
hyperpar['M'] = M
hyperpar['k_max'] = k_max

# MCMC parameters
# number of posterior samples = (MCMC - BURNIN) / THIN
MCMC = 100    # MCMC iterations
BURNIN = 50  # burnin period length
THIN = 5        # thinning intervals

BASTIONfit_C(z, test_graph, init_val, hyperpar, MCMC, BURNIN, THIN, seed = 12345)


}
